<html>
    <head>
        <style>
            * {
                box-sizing: border-box;
            }
            .container {
                width: 900px;
                height: 600px;
                margin: auto;
                position: relative;
                border: 1px solid gray;
            }
            .block {
                width: 150px;
                height: 150px;
                border: 1px solid black;
                position: absolute;
                background: #FEFEFE;
            }
            #block1 {
                top: 50px;
                left: 100px;
            }
            #block2 {
                top: 400px;
                left: 500px;
            }
            #block3 {
                top: 100px;
                left: 500px;
            }
            
            .block .connector {
                position: absolute;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                background: grey;
            }
            .block .connector.top {
                left: 50%;
                top: 0;
                margin-left: -5px;
                margin-top: -5px;
            }
            .block .connector.bottom {
                left: 50%;
                bottom: 0;
                margin-left: -5px;
                margin-bottom: -5px;
            }

            #canvas {
                position: absolute;
                top: 1;
                left: 1;
                width: 100%;
                height: 100%;
            }
        </style>
        <script
            src="https://code.jquery.com/jquery-3.3.1.min.js"
            integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
            crossorigin="anonymous"></script>
        <script
            src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
            integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU="
            crossorigin="anonymous"></script>
    </head>
    <body>
        <div class="container">
            <canvas id="canvas"></canvas>
            <div class="block" id="block1"></div>
            <div class="block" id="block2"></div>
            <div class="block" id="block3"></div>
        </div>

        <script>
            $(function() {
                $('.block').draggable({
                    drag: function() {
                        b1.calcConnectorPositions();
                        b2.calcConnectorPositions();
                        b3.calcConnectorPositions();
                        plot.redraw();
                    }
                });
                
                var $canvas = $('canvas');
                $canvas.attr('width', $canvas.width());
                $canvas.attr('height', $canvas.height());
                context = $canvas[0].getContext("2d");

                function Plot(context) {
                    this.context = context;
                    this.connections = [];

                    this.addConnection = function (connection) {
                        this.connections.push(connection);
                    }

                    this.redraw = function() {
                        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
                        for(var i = 0; i < this.connections.length; i++) {
                            this.connections[i].draw(this.context);
                        }
                    }
                }
                
                function Connection(config) {
                    this.source = config.source;
                    this.destination = config.destination;
                    this.source.connections.push(this.destination);
                    this.destination.connections.push(this.source);

                    this.remove = function () {
                        var index = this.source.connections.indexOf(this.destination);
                        this.source.connections.splice(index, 1);

                        index = this.destination.connections.indexOf(this.source);
                        this.destination.connections.splice(index, 1);
                    }
                    this.draw = function(context, config) {
                        config = config || {};

                        if (this.source.position !== 'bottom' || this.destination.position !== 'top') {
                            throw 'Currently only bottom position is supported for sources and top for destinations';
                        }

                        var rowspan = config.rowspan || 20;
                        var colspan = config.colspan || 20;
                        var sourceRadius = this.source.$.width() / 2;
                        var destRadius = this.destination.$.width() / 2;

                        var blockWidth = this.source.block.$.width();
                        var blockHeight = this.source.block.$.height();

                        var sourcePosition = this.source.block.$.position();
                        var destPosition = this.destination.block.$.position();
                        
                        var sourcePos = { left: sourcePosition.left + blockWidth / 2, top: sourcePosition.top + blockHeight };
                        var destPos = { left: destPosition.left + blockWidth / 2, top: destPosition.top };
                        
                        var sourceD = this.source.d;
                        var destD = this.destination.d;

                        context.beginPath();
                        context.strokeStyle = this.source.color;
                        context.moveTo(sourcePos.left + sourceD, sourcePos.top + sourceRadius);
                        if (destPos.top > sourcePos.top + colspan) {
                            var left = Math.min(Math.abs(destPos.left + destD - sourcePos.left - sourceD) / 2, colspan / 2);

                            if (destPos.left + destD > sourcePos.left + sourceD) {
                                context.quadraticCurveTo(sourcePos.left + sourceD, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left + sourceD + left, sourcePos.top + sourceRadius + rowspan / 2);
                                context.lineTo(destPos.left + destD - left, sourcePos.top + sourceRadius + rowspan / 2);
                            } else {
                                context.quadraticCurveTo(sourcePos.left + sourceD, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left + sourceD - left, sourcePos.top + sourceRadius + rowspan / 2);
                                context.lineTo(destPos.left + destD + left, sourcePos.top + sourceRadius + rowspan / 2);
                            }
                            context.quadraticCurveTo(destPos.left + destD, sourcePos.top + sourceRadius + rowspan / 2, destPos.left+ destD, sourcePos.top + sourceRadius + rowspan / 2 * 2);
                        } else {
                            var left = colspan / 2;
                            if (destPos.left > sourcePos.left) {
                                context.quadraticCurveTo(sourcePos.left + sourceD, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left + sourceD + left, sourcePos.top + sourceRadius + rowspan / 2);
                                context.lineTo(sourcePos.left + blockWidth / 2, sourcePos.top + sourceRadius + rowspan / 2);

                                if (destPos.left - blockWidth - colspan > sourcePos.left) {
                                    context.quadraticCurveTo(sourcePos.left + blockWidth / 2 + colspan / 2, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left + blockWidth / 2 + colspan / 2, sourcePos.top + sourceRadius);
                                    context.lineTo(sourcePos.left + blockWidth / 2 + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                    context.quadraticCurveTo(sourcePos.left + blockWidth / 2 + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, sourcePos.left + blockWidth / 2 + colspan, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.lineTo(destPos.left + destD - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.quadraticCurveTo(destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                } else {
                                    context.lineTo(destPos.left + blockWidth / 2, sourcePos.top + sourceRadius + rowspan / 2);
                                    context.quadraticCurveTo(destPos.left + blockWidth / 2 + colspan / 2, sourcePos.top + sourceRadius + rowspan / 2, destPos.left + blockWidth / 2 + colspan / 2, sourcePos.top + sourceRadius);
                                    context.lineTo(destPos.left + blockWidth / 2 + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                    context.quadraticCurveTo(destPos.left + blockWidth / 2 + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left + blockWidth / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.lineTo(destPos.left + destD + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.quadraticCurveTo(destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                }
                            } else {
                                context.quadraticCurveTo(sourcePos.left + sourceD, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left + sourceD - left, sourcePos.top + sourceRadius + rowspan / 2);
                                context.lineTo(sourcePos.left - blockWidth / 2, sourcePos.top + sourceRadius + rowspan / 2);

                                if (sourcePos.left - blockWidth - colspan > destPos.left) {
                                    context.quadraticCurveTo(sourcePos.left - blockWidth / 2 - colspan / 2, sourcePos.top + sourceRadius + rowspan / 2, sourcePos.left - blockWidth / 2 - colspan / 2, sourcePos.top + sourceRadius);
                                    context.lineTo(sourcePos.left - blockWidth / 2 - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                    context.quadraticCurveTo(sourcePos.left - blockWidth / 2 - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, sourcePos.left - blockWidth / 2 - colspan, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.lineTo(destPos.left + destD + colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.quadraticCurveTo(destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                } else {
                                    context.lineTo(destPos.left - blockWidth / 2, sourcePos.top + sourceRadius + rowspan / 2);
                                    context.quadraticCurveTo(destPos.left - blockWidth / 2 - colspan / 2, sourcePos.top + sourceRadius + rowspan / 2, destPos.left - blockWidth / 2 - colspan / 2, sourcePos.top + sourceRadius);
                                    context.lineTo(destPos.left - blockWidth / 2 - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                    context.quadraticCurveTo(destPos.left - blockWidth / 2 - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left - blockWidth / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.lineTo(destPos.left + destD - colspan / 2, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius);
                                    context.quadraticCurveTo(destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - rowspan / 2 - destRadius, destPos.left + destD, Math.min(destPos.top, sourcePos.top - rowspan / 4) - destRadius);
                                }
                            }
                        }
                        context.lineTo(destPos.left + destD, destPos.top - 2);
                        
                        // arrow
                        context.lineTo(destPos.left + destD - 5, destPos.top - 6 - 2);
                        context.moveTo(destPos.left + destD, destPos.top - 2);
                        context.lineTo(destPos.left + destD + 5, destPos.top - 6 - 2);

                        context.stroke();
                    }
                }

                function Block(el, plot) {
                    this.connectors = [];
                    this.plot = plot;
                    this.$ = $(el);
                    
                    this.connect = function (block, config) {
                        config = config || {};
                        var source = new Connector({ type: 'source', color: config.color });
                        this.addConnector(source);
                        var destination = new Connector({ type: 'destination' });
                        block.addConnector(destination);
                        var connection = new Connection({ source: source, destination: destination });
                        this.plot.addConnection(connection);
                    }
                    this.addConnector = function(connector) {
                        this.connectors.push(connector);
                        connector.block = this;
                        connector.redraw();
                        this.calcConnectorPositions();
                    };
                    this.removeConnector = function(connector) {
                        var index = this.connectors.indexOf(connector);
                        this.connectors.splice(index, 1);
                        connector.block = null;
                        this.calcConnectorPositions();
                    };
                    this.setPositions = function (connectors, size) {
                        if (!connectors.length) {
                            return;
                        }

                        var array = connectors.map(function(c) { return { c: c, left: c.getAvgConnectionDirection().left } });
                        array.sort(function(a, b) { return a.left - b.left; });
                        connectors = array.map(function(c) { return c.c; });

                        var zone = size / connectors.length;
                        var middle = size / 2;
                        for (var i = 0; i < connectors.length; i++) {
                            connectors[i].translate((i * zone + (i + 1) * zone) / 2 - middle); 
                        }
                    }
                    this.calcConnectorPositions = function() {
                        var width = this.$.width();
                        var top = this.connectors.filter(function(c) { return c.position === 'top'; });
                        this.setPositions(top, width);
                        
                        var bottom = this.connectors.filter(function(c) { return c.position === 'bottom'; });
                        this.setPositions(bottom, width);
                    }
                }

                function Connector(config) {
                    this.connections = [];
                    this.type = config.type || 'source';
                    this.position = config.position || (this.type === 'source' ? 'bottom' : 'top');
                    this.color = config.color || (this.type === 'source' ? 'blue' : 'transparent');
                    this.block = null;
                    this.$ = null;
                    this.d = 0;

                    this.getAvgConnectionDirection = function() {
                        if (!this.connections || !this.connections.length) {
                            return { left: 0, top: 0 };
                        }
                        var left = 0;
                        var top = 0;
                        var p = this.block.$.position();
                        for (var i = 0; i < this.connections.length; i++) {
                            var cp = this.connections[i].block.$.position();
                            left += cp.left - p.left;
                            top += cp.top - p.top;
                        }
                        return { left: left / this.connections.length, top: top / this.connections.length };
                    }

                    this.redraw = function () {
                        if (this.$) {
                            this.$.remove();
                        }
                        this.$ = $('<div/>', { class: 'connector' });

                        if (this.type === 'source') {
                            this.$.addClass('source');
                        } else {
                            this.$.addClass('destination');
                        }

                        if (this.position === 'top') {
                            this.$.addClass('top');
                        } else if (this.position === 'bottom') {
                            this.$.addClass('bottom');
                        } else {
                            throw 'Not supported';
                        }
                        this.$.css('background-color', this.color);
                        this.block.$.append(this.$);
                    }
                    this.remove = function () {
                        this.d = 0;
                        if (this.$) {
                            this.$.remove();
                        }
                        this.block.removeConnector(this);
                    }
                    this.translate = function(val) {
                        this.d = val;
                        if (this.position === 'top' || this.position === 'bottom') {
                            this.$.css('transform', 'translate(' + val + 'px, 0px)');
                        }
                    }
                }
                
                var plot = new Plot(context);
                var b1 = new Block('#block1', plot);
                var b2 = new Block('#block2', plot);
                var b3 = new Block('#block3', plot);
                b1.connect(b2);
                b1.connect(b3, { color: 'red' });
                b2.connect(b3, { color: 'green' });
                plot.redraw();
            });
        </script>
    </body>
</html>